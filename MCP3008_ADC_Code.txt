#include <msp430.h>

#define BIT_0           0x01
#define BIT_1           0x02
#define BIT_2           0x04
#define BIT_3           0x08
#define BIT_4           0x10
#define BIT_5           0x20
#define BIT_6           0x40
#define BIT_7           0x80

volatile float received_ch1 = 0;
volatile float received_ch2 = 0;
int main(void)
{
    WDTCTL = WDTPW + WDTHOLD; // Stop WDT

    P2DIR = 0x01;
    P1OUT |= BIT5;
    P1DIR |= BIT5;
    P1SEL = BIT1 | BIT2 | BIT4;
    P1SEL2 = BIT1 | BIT2 | BIT4;

    while(1)
    {

        UCA0CTL1 = UCSWRST;
        UCA0CTL0 |= UCCKPH + UCMSB + UCMST + UCSYNC; // 3-pin, 8-bit SPI master
        UCA0CTL1 |= UCSSEL_2; // SMCLK
        UCA0BR0 |= 0x02; // /2
        UCA0BR1 = 0; //
        UCA0MCTL = 0; // No modulation
        UCA0CTL1 &= ~UCSWRST; // **Initialize USCI state machine**

        P1OUT &= (BIT5); // Select Device
        P1OUT &= (~BIT5);
        while (!(IFG2 & UCA0TXIFG)); // USCI_A0 TX buffer ready?
        UCA0TXBUF = 0x01; // Send 0x18 over SPI to Slave
        while ((!(IFG2 & UCA0TXIFG)) && (!(IFG2 & UCA0RXIFG))); // USCI_A0 TX buffer ready?
        UCA0TXBUF = 0x80; // Send 0x18 over SPI to Slave
        received_ch1 = UCA0RXBUF; // Store received data
        while ((!(IFG2 & UCA0TXIFG)) && (!(IFG2 & UCA0RXIFG))); // USCI_A0 TX buffer ready?
        UCA0TXBUF = 0x80; // Send 0x18 over SPI to Slave
        received_ch2 = UCA0RXBUF; // Store received data

        P1OUT |= (BIT5); // Unselect Device

        if (((received_ch1 >= 00000010) || (received_ch1 >= 11111110)) && (recived_ch2 >= 0))
        {
            P2OUT = 0x01;
        }
        else
        {
            P2OUT = 0x00;
        }
    }
}